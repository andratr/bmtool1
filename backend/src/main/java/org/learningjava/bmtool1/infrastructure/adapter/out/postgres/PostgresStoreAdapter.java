// src/main/java/org/learningjava/bmtool1/infrastructure/adapter/out/postgres/PostgresStoreAdapter.java
package org.learningjava.bmtool1.infrastructure.adapter.out.postgres;

import jakarta.annotation.PostConstruct;
import org.learningjava.bmtool1.application.port.ExperimentStorePort;
import org.learningjava.bmtool1.domain.model.analytics.Experiment;
import org.springframework.stereotype.Component;

import javax.sql.DataSource;
import java.sql.*;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

@Component
public class PostgresStoreAdapter implements ExperimentStorePort {
    private final DataSource ds;

    public PostgresStoreAdapter(DataSource ds) { this.ds = ds; }

    /* ------------------------ schema ------------------------ */

    @PostConstruct
    public void init() { ensureSchema(); }
    @Override
    public void ensureSchema() {
        final String ddl = """
        -- 1) Create table if missing
        CREATE TABLE IF NOT EXISTS experiments (
          id                   BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
          experiment_date      DATE NOT NULL,
          -- keep minimal columns here; full shape enforced below
          created_at           TIMESTAMPTZ NOT NULL DEFAULT now(),
          updated_at           TIMESTAMPTZ NOT NULL DEFAULT now()
        );

        -- 2) Add missing columns (idempotent, safe on existing DBs)
        ALTER TABLE experiments
          ADD COLUMN IF NOT EXISTS fw_hits_count        INTEGER,
          ADD COLUMN IF NOT EXISTS doc_hits_count       INTEGER,
          ADD COLUMN IF NOT EXISTS k_fw                 INTEGER,
          ADD COLUMN IF NOT EXISTS k_doc                INTEGER,
          ADD COLUMN IF NOT EXISTS prompt               TEXT,
          ADD COLUMN IF NOT EXISTS embedding_model      TEXT,
          ADD COLUMN IF NOT EXISTS llm_model            TEXT,
          ADD COLUMN IF NOT EXISTS metric1_ccc          DOUBLE PRECISION,
          ADD COLUMN IF NOT EXISTS metric2_time_ms      DOUBLE PRECISION,
          ADD COLUMN IF NOT EXISTS metric3_co2_g        DOUBLE PRECISION,
          ADD COLUMN IF NOT EXISTS metric4_prompt_tok   INTEGER,
          ADD COLUMN IF NOT EXISTS metric5_completion_tok INTEGER,
          ADD COLUMN IF NOT EXISTS metric6_total_tok    INTEGER,
          ADD COLUMN IF NOT EXISTS prompting_technique  TEXT;

        -- 3) Backfill sensible defaults where NULL
        UPDATE experiments SET fw_hits_count  = 0  WHERE fw_hits_count  IS NULL;
        UPDATE experiments SET doc_hits_count = 0  WHERE doc_hits_count IS NULL;
        UPDATE experiments SET k_fw           = 0  WHERE k_fw           IS NULL;
        UPDATE experiments SET k_doc          = 0  WHERE k_doc          IS NULL;

        -- 4) Enforce NOT NULL + defaults (done after backfill)
        ALTER TABLE experiments
          ALTER COLUMN fw_hits_count        SET DEFAULT 0,
          ALTER COLUMN fw_hits_count        SET NOT NULL,
          ALTER COLUMN doc_hits_count       SET DEFAULT 0,
          ALTER COLUMN doc_hits_count       SET NOT NULL,
          ALTER COLUMN k_fw                 SET DEFAULT 0,
          ALTER COLUMN k_fw                 SET NOT NULL,
          ALTER COLUMN k_doc                SET DEFAULT 0,
          ALTER COLUMN k_doc                SET NOT NULL,
          ALTER COLUMN prompt               SET NOT NULL,
          ALTER COLUMN embedding_model      SET NOT NULL,
          ALTER COLUMN llm_model            SET NOT NULL;

        -- 5) Clean up legacy columns (your existing block)
        DO $$
        BEGIN
          IF EXISTS (SELECT 1 FROM information_schema.columns 
                     WHERE table_name='experiments' AND column_name='num_samples') THEN
            ALTER TABLE experiments
              DROP COLUMN IF EXISTS num_samples,
              DROP COLUMN IF EXISTS num_rag_samples,
              DROP COLUMN IF EXISTS k;
          END IF;
        EXCEPTION WHEN others THEN NULL; END $$;

        -- 6) Helpful indexes
        CREATE INDEX IF NOT EXISTS idx_experiments_date
          ON experiments (experiment_date);
        CREATE INDEX IF NOT EXISTS idx_experiments_models
          ON experiments (embedding_model, llm_model);

        -- 7) Natural uniqueness (guarded by name)
        DO $$
        BEGIN
          IF NOT EXISTS (
            SELECT 1 FROM pg_constraint WHERE conname = 'uq_experiment_natural2'
          ) THEN
            ALTER TABLE experiments
              ADD CONSTRAINT uq_experiment_natural2
              UNIQUE (experiment_date, embedding_model, llm_model, k_fw, k_doc, prompting_technique, prompt);
          END IF;
        EXCEPTION WHEN others THEN NULL; END $$;

        -- 8) updated_at trigger
        CREATE OR REPLACE FUNCTION set_updated_at() RETURNS trigger AS $$
        BEGIN NEW.updated_at = now(); RETURN NEW; END; $$ LANGUAGE plpgsql;

        DROP TRIGGER IF EXISTS trg_set_updated_at ON experiments;
        CREATE TRIGGER trg_set_updated_at
          BEFORE UPDATE ON experiments
          FOR EACH ROW EXECUTE FUNCTION set_updated_at();
        """;

        try (Connection c = ds.getConnection(); Statement st = c.createStatement()) {
            st.execute(ddl);
        } catch (SQLException e) {
            throw new RuntimeException("ensureSchema failed", e);
        }
    }


    /* ------------------------ bindings ------------------------ */

    private static void bindWithoutId(PreparedStatement ps, Experiment e) throws SQLException {
        ps.setDate(1,  Date.valueOf(e.experimentDate()));
        ps.setInt(2,   e.fwHitsCount());
        ps.setInt(3,   e.docHitsCount());
        ps.setInt(4,   e.kFw());
        ps.setInt(5,   e.kDoc());
        ps.setString(6, e.prompt());
        ps.setString(7, e.embeddingModel());
        ps.setString(8, e.llmModel());
        setNullable(ps, 9,  e.metric1Ccc());
        setNullable(ps, 10, e.metric2TimeMs());
        setNullable(ps, 11, e.metric3Co2G());
        setNullableInt(ps, 12, e.metric4PromptTok());
        setNullableInt(ps, 13, e.metric5CompletionTok());
        setNullableInt(ps, 14, e.metric6TotalTok());
        ps.setString(15, e.promptingTechnique());
    }

    private static Experiment map(ResultSet rs) throws SQLException {
        return new Experiment(
                rs.getLong("id"),
                rs.getObject("experiment_date", LocalDate.class),
                rs.getInt("fw_hits_count"),
                rs.getInt("doc_hits_count"),
                rs.getInt("k_fw"),
                rs.getInt("k_doc"),
                rs.getString("prompt"),
                rs.getString("embedding_model"),
                rs.getString("llm_model"),
                getNullableDouble(rs, "metric1_ccc"),
                getNullableDouble(rs, "metric2_time_ms"),
                getNullableDouble(rs, "metric3_co2_g"),
                getNullableInt(rs, "metric4_prompt_tok"),
                getNullableInt(rs, "metric5_completion_tok"),
                getNullableInt(rs, "metric6_total_tok"),
                rs.getString("prompting_technique")
        );
    }

    private static void setNullable(PreparedStatement ps, int idx, Double v) throws SQLException {
        if (v == null) ps.setNull(idx, Types.DOUBLE); else ps.setDouble(idx, v);
    }
    private static void setNullableInt(PreparedStatement ps, int idx, Integer v) throws SQLException {
        if (v == null) ps.setNull(idx, Types.INTEGER); else ps.setInt(idx, v);
    }
    private static Double getNullableDouble(ResultSet rs, String col) throws SQLException {
        double v = rs.getDouble(col); return rs.wasNull() ? null : v;
    }
    private static Integer getNullableInt(ResultSet rs, String col) throws SQLException {
        int v = rs.getInt(col); return rs.wasNull() ? null : v;
    }

    /* ------------------------ CRUD ------------------------ */

    @Override
    public long upsert(Experiment e) {
        final String sql = """
            INSERT INTO experiments
              (experiment_date, fw_hits_count, doc_hits_count, k_fw, k_doc,
               prompt, embedding_model, llm_model,
               metric1_ccc, metric2_time_ms, metric3_co2_g,
               metric4_prompt_tok, metric5_completion_tok, metric6_total_tok,
               prompting_technique)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ON CONFLICT ON CONSTRAINT uq_experiment_natural2 DO UPDATE SET
              fw_hits_count       = EXCLUDED.fw_hits_count,
              doc_hits_count      = EXCLUDED.doc_hits_count,
              metric1_ccc         = EXCLUDED.metric1_ccc,
              metric2_time_ms     = EXCLUDED.metric2_time_ms,
              metric3_co2_g       = EXCLUDED.metric3_co2_g,
              metric4_prompt_tok  = EXCLUDED.metric4_prompt_tok,
              metric5_completion_tok = EXCLUDED.metric5_completion_tok,
              metric6_total_tok   = EXCLUDED.metric6_total_tok,
              updated_at          = now()
            RETURNING id
            """;
        try (Connection c = ds.getConnection();
             PreparedStatement ps = c.prepareStatement(sql)) {
            bindWithoutId(ps, e);
            try (ResultSet rs = ps.executeQuery()) {
                if (!rs.next()) throw new SQLException("No id returned from upsert");
                return rs.getLong(1);
            }
        } catch (SQLException ex) { throw new RuntimeException("upsert failed", ex); }
    }

    @Override
    public List<Long> upsertBatch(List<Experiment> list) {
        final String sql = """
            INSERT INTO experiments
              (experiment_date, fw_hits_count, doc_hits_count, k_fw, k_doc,
               prompt, embedding_model, llm_model,
               metric1_ccc, metric2_time_ms, metric3_co2_g,
               metric4_prompt_tok, metric5_completion_tok, metric6_total_tok,
               prompting_technique)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ON CONFLICT ON CONSTRAINT uq_experiment_natural2 DO UPDATE SET
              fw_hits_count       = EXCLUDED.fw_hits_count,
              doc_hits_count      = EXCLUDED.doc_hits_count,
              metric1_ccc         = EXCLUDED.metric1_ccc,
              metric2_time_ms     = EXCLUDED.metric2_time_ms,
              metric3_co2_g       = EXCLUDED.metric3_co2_g,
              metric4_prompt_tok  = EXCLUDED.metric4_prompt_tok,
              metric5_completion_tok = EXCLUDED.metric5_completion_tok,
              metric6_total_tok   = EXCLUDED.metric6_total_tok,
              updated_at          = now()
            RETURNING id
            """;
        List<Long> ids = new ArrayList<>(list.size());
        try (Connection c = ds.getConnection();
             PreparedStatement ps = c.prepareStatement(sql)) {
            c.setAutoCommit(false);
            for (Experiment e : list) {
                bindWithoutId(ps, e);
                try (ResultSet rs = ps.executeQuery()) {
                    if (!rs.next()) throw new SQLException("No id returned from upsertBatch");
                    ids.add(rs.getLong(1));
                }
            }
            c.commit();
            return ids;
        } catch (SQLException ex) { throw new RuntimeException("upsertBatch failed", ex); }
    }

    @Override
    public Optional<Experiment> findById(long id) {
        final String sql = "SELECT * FROM experiments WHERE id = ?";
        try (Connection c = ds.getConnection(); PreparedStatement ps = c.prepareStatement(sql)) {
            ps.setLong(1, id);
            try (ResultSet rs = ps.executeQuery()) {
                return rs.next() ? Optional.of(map(rs)) : Optional.empty();
            }
        } catch (SQLException ex) { throw new RuntimeException("findById failed", ex); }
    }

    @Override
    public List<Experiment> listByDateRange(LocalDate fromInclusive, LocalDate toInclusive) {
        final String sql = """
            SELECT * FROM experiments
            WHERE experiment_date BETWEEN ? AND ?
            ORDER BY experiment_date DESC, id DESC
            """;
        try (Connection c = ds.getConnection(); PreparedStatement ps = c.prepareStatement(sql)) {
            ps.setDate(1, Date.valueOf(fromInclusive));
            ps.setDate(2, Date.valueOf(toInclusive));
            try (ResultSet rs = ps.executeQuery()) {
                List<Experiment> out = new ArrayList<>();
                while (rs.next()) out.add(map(rs));
                return out;
            }
        } catch (SQLException ex) { throw new RuntimeException("listByDateRange failed", ex); }
    }

    @Override
    public List<Experiment> listByModels(String embeddingModel, String llmModel) {
        final String sql = """
            SELECT * FROM experiments
            WHERE embedding_model = ? AND llm_model = ?
            ORDER BY experiment_date DESC, id DESC
            """;
        try (Connection c = ds.getConnection(); PreparedStatement ps = c.prepareStatement(sql)) {
            ps.setString(1, embeddingModel);
            ps.setString(2, llmModel);
            try (ResultSet rs = ps.executeQuery()) {
                List<Experiment> out = new ArrayList<>();
                while (rs.next()) out.add(map(rs));
                return out;
            }
        } catch (SQLException ex) { throw new RuntimeException("listByModels failed", ex); }
    }
}
